import React, { useEffect, useMemo, useState } from 'react';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { CommonActions, createNavigationContainerRef, DrawerActions, NavigationContainer, StackActions, TabActions, useNavigation, useRoute, } from '@react-navigation/native';
import { createNativeStackNavigator, } from '@react-navigation/native-stack';
import { createDrawerNavigator } from '@react-navigation/drawer';
import { NavioTunnel } from './tunnel';
import { safeOpts } from './help';
// Navio
export class Navio {
    static build(data) {
        const _navio = new Navio(data);
        return _navio;
    }
    // ========
    // | Vars |
    // ========
    layout;
    // react navigation related
    navRef;
    navIsReadyRef;
    // for data transfer
    tunnel;
    // updated options for tabs and drawers. used to store data during session
    __tabsUpdatedOptions = {};
    __drawerUpdatedOptions = {};
    // params for modals. used to easier transfer data to modal
    __modalParams = {};
    // ========
    // | Init |
    // ========
    constructor(data) {
        // Layout
        this.layout = data;
        // Navigation
        this.navRef = createNavigationContainerRef();
        this.navIsReadyRef = React.createRef();
        // Tunnel (event emitter)
        this.tunnel = new NavioTunnel();
    }
    // ===========
    // | Getters |
    // ===========
    get N() {
        return this.navRef;
    }
    get navIsReady() {
        return (!!this.navIsReadyRef && this.navIsReadyRef.current && !!this.navRef && !!this.navRef.current);
    }
    // ===========
    // | Methods |
    // ===========
    log(message, type = 'log') {
        console[type](`[navio] ${message}`);
    }
    __setRoot(routeName) {
        const { stacks, tabs, drawers } = this.layout;
        if (stacks && stacks[routeName]) {
            this.stacks.setRoot(routeName);
        }
        if (tabs && tabs[routeName]) {
            this.tabs.setRoot(routeName);
        }
        if (drawers && drawers[routeName]) {
            this.drawers.setRoot(routeName);
        }
    }
    getSafeRoot(name) {
        if (!name)
            return undefined;
        const { stacks, tabs, drawers } = this.layout;
        const split = name.split('.');
        const type = split[0]; // tabs, stacks, drawers
        const routeName = split.slice(1).join(':');
        if (type === 'tabs') {
            const rName = routeName;
            if (!!tabs && !tabs[rName]) {
                this.log('Wrong app root', 'warn');
            }
            return rName;
        }
        if (type === 'stacks') {
            const rName = routeName;
            if (!!stacks && !stacks[rName]) {
                this.log('Wrong app root', 'warn');
            }
            return rName;
        }
        if (type === 'drawers') {
            const rName = routeName;
            if (!!drawers && !drawers[rName]) {
                this.log('Wrong app root', 'warn');
            }
            return rName;
        }
    }
    getCustomDefaultOptions() {
        return {
            stacks: {
                container: {
                    headerShown: false,
                },
            },
            tabs: {
                container: {
                    headerShown: false,
                },
                screen: {
                    headerShown: false,
                },
            },
            drawers: {
                container: {
                    headerShown: false,
                },
                screen: {
                    headerShown: false,
                },
            },
            modals: {
                container: {
                    headerShown: false,
                },
            },
        };
    }
    navigate = (name, params) => {
        if (this.navIsReady) {
            this.navRef.current?.dispatch(CommonActions.navigate({
                name: name,
                params,
            }));
        }
    };
    // ===========
    // | Actions |
    // ===========
    /**
     * `push(...)` action adds a route on top of the stack and navigates forward to it.
     *
     * @param name ScreenName
     * @param params Params
     */
    push(name, params) {
        if (this.navIsReady) {
            this.navRef.current?.dispatch(StackActions.push(name, params));
        }
    }
    /**
     * `goBack()` action creator allows to go back to the previous route in history.
     */
    goBack() {
        if (this.navIsReady) {
            this.navRef.current?.goBack();
        }
    }
    /**
     * `setParams(...)` action allows to update params for a certain route.
     *
     * @param name all available navigation keys. Leave `undefined` if applying for the focused route.
     * @param params object
     */
    setParams(name, params) {
        if (this.navIsReady) {
            this.navRef.current?.dispatch({
                ...CommonActions.setParams(params),
                source: name,
            });
        }
    }
    /**
     * `setRoot(as, name)` action sets a new app root.
     *
     * Tips: It can be used to switch between Tabs, Drawers, and Stacks.
     *
     * @param as used to define the type of the app layout. Possible values: 'stacks' | 'tabs' | 'drawers'.
     * @param name will be autocompleted based on `as` value and current layout configuration.
     */
    setRoot(as, routeName) {
        if (as) {
            this.__setRoot(routeName);
        }
    }
    /**
     * `stacks` contains navigation actions for stack-based navigators.
     *
     * Available methods:
     *
     * `push`, `pop`, `popToTop`, `setRoot`
     *
     */
    get stacks() {
        // local copy of current instance
        const self = this;
        return {
            /**
             * `push(...)` action adds a route on top of the stack and navigates forward to it.
             *
             * Tips: It will "hide" tabs.
             *
             * @param name StackName
             */
            push(name) {
                if (self.navIsReady) {
                    self.navigate(name);
                }
            },
            /**
             * `pop(...)` action takes you back to a previous screen in the stack.
             *
             * @param count number
             */
            pop(count) {
                if (self.navIsReady) {
                    self.navRef.current?.dispatch(StackActions.pop(count));
                }
            },
            /**
             * `popToPop()` action takes you back to the first screen in the stack, dismissing all the others.
             */
            popToTop() {
                if (self.navIsReady) {
                    self.navRef.current?.dispatch(StackActions.popToTop());
                }
            },
            /**
             * `setRoot(...)` action sets a new app root from stacks.
             *
             * Tips: It can be used to switch between Auth and App stacks.
             *
             * @param name StackName
             */
            setRoot(name) {
                if (self.navIsReady) {
                    self.navRef.current?.dispatch(CommonActions.reset({
                        routes: [{ name }],
                    }));
                }
            },
        };
    }
    /**
     * `tabs` contains navigation actions for tab-based navigators.
     *
     * Available methods:
     *
     * `jumpTo`, `setRoot`
     *
     */
    get tabs() {
        // local copy of current instance
        const self = this;
        return {
            /**
             * `jumpTo(...)` action can be used to jump to an existing route in the tab navigator.
             *
             * @param name TabName
             */
            jumpTo(name) {
                if (self.navIsReady) {
                    self.navRef.current?.dispatch(TabActions.jumpTo(name));
                }
            },
            /**
             * `updateOptions(...)` action updates provided tab's options.
             *
             * Tips: It can be used to update badge count.
             *
             * @param name name of the tab
             * @param options `BottomTabNavigationOptions` options for the tab.
             */
            updateOptions(name, options) {
                if (self.navIsReady) {
                    self.tunnel.echo('tabs.updateOptions', {
                        name,
                        options,
                    });
                }
            },
            /**
             * `setRoot(...)` action sets a new app root from tabs.
             *
             * Tips: It can be used to switch between Auth and Tabs.
             *
             * @param name TabsName
             */
            setRoot(name) {
                if (self.navIsReady) {
                    self.navRef.current?.dispatch(CommonActions.reset({
                        routes: [{ name }],
                    }));
                }
            },
        };
    }
    /**
     * `modals` contains navigation actions for modals.
     *
     * Available methods:
     *
     * `show`
     *
     */
    get modals() {
        // local copy of current instance
        const self = this;
        return {
            /**
             * `show(...)` action can be used to show an existing modal.
             *
             * @param name ModalName
             */
            show(name, params) {
                if (self.navIsReady) {
                    // adding params to modals params data
                    if (!!params) {
                        self.__modalParams[name] = params;
                    }
                    self.navigate(name);
                }
            },
            /**
             * `getParams(...)` action can be used to get params passed to the modal.
             *
             * @param name ModalName
             */
            getParams(name) {
                return self.__modalParams[name];
            },
        };
    }
    /**
     * `drawers` contains navigation actions for drawer-based navigators.
     *
     * Available methods:
     *
     * `open`, `close`, `toggle`, `jumpTo`, `setRoot`
     *
     */
    get drawers() {
        // local copy of current instance
        const self = this;
        return {
            /**
             * `open()` action can be used to open the drawer pane.
             */
            open() {
                if (self.navIsReady) {
                    self.navRef.current?.dispatch(DrawerActions.openDrawer());
                }
            },
            /**
             * `close()` action can be used to close the drawer pane.
             */
            close() {
                if (self.navIsReady) {
                    self.navRef.current?.dispatch(DrawerActions.closeDrawer());
                }
            },
            /**
             * `toggle()` action can be used to open the drawer pane if closed, or close if open.
             */
            toggle() {
                if (self.navIsReady) {
                    self.navRef.current?.dispatch(DrawerActions.toggleDrawer());
                }
            },
            /**
             * `jumpTo(...)` action can be used to jump to an existing route in the drawer navigator.
             *
             * @param name StacksName
             */
            jumpTo(name) {
                if (self.navIsReady) {
                    self.navRef.current?.dispatch(DrawerActions.jumpTo(name));
                }
            },
            /**
             * `updateOptions(...)` action updates provided drawer's options.
             *
             * @param name name of the drawer layout
             * @param options `DrawerNavigationOptions` options for the drawer.
             */
            updateOptions(name, options) {
                if (self.navIsReady) {
                    self.tunnel.echo('drawer.updateOptions', {
                        name,
                        options,
                    });
                }
            },
            /**
             * `setRoot(...)` action sets a new app root from drawers.
             *
             * Tips: It can be used to switch between Auth and Drawers.
             *
             * @param name DrawersName
             */
            setRoot(name) {
                if (self.navIsReady) {
                    self.navRef.current?.dispatch(CommonActions.reset({
                        routes: [{ name }],
                    }));
                }
            },
        };
    }
    // =========
    // | Hooks |
    // =========
    /**
     * `useN()` is the duplicate of `useNavigation()` hook from React Navigation.
     *
     */
    useN() {
        return useNavigation();
    }
    /**
     * `useR()` is the duplicate of `useRoute()` hook from React Navigation.
     *
     */
    useR() {
        return useRoute();
    }
    /**
     * `useParams()` is used to quickly extract params from the React Navigation route.
     *
     */
    useParams() {
        return useRoute()?.params;
    }
    // ===========
    // | Layouts |
    // ===========
    // | Stacks |
    // some getters for Stack
    __StackGetNavigatorProps = (definition) => {
        const { stacks } = this.layout;
        if (stacks === undefined)
            return {};
        return Array.isArray(definition)
            ? // if definition is ScreenName[]
                {}
            : // if stackDev is TStacksDataObj
                typeof definition === 'object'
                    ? definition.navigatorProps ?? {}
                    : // if stackDev is StacksName -> look into stacks[...]
                        typeof definition === 'string'
                            ? // if stacks[name] is ScreenName[]
                                Array.isArray(stacks[definition])
                                    ? {}
                                    : // if stacks[name] is TStacksDataObj
                                        typeof stacks[definition] === 'object'
                                            ? stacks[definition].navigatorProps ?? {}
                                            : {}
                            : {};
    };
    __StackGetContainerOpts = (definition) => {
        const { stacks } = this.layout;
        if (stacks === undefined)
            return {};
        return Array.isArray(definition)
            ? // if definition is ScreenName[]
                {}
            : // if stackDev is TStacksDataObj
                typeof definition === 'object'
                    ? definition.options ?? {}
                    : // if stackDev is StacksName -> look into stacks[...]
                        typeof definition === 'string'
                            ? // if stacks[name] is ScreenName[]
                                Array.isArray(stacks[definition])
                                    ? {}
                                    : // if stacks[name] is TStacksDataObj
                                        typeof stacks[definition] === 'object'
                                            ? stacks[definition].options ?? {}
                                            : {}
                            : {};
    };
    __StackGetScreens = (definition) => {
        const { stacks } = this.layout;
        if (stacks === undefined)
            return [];
        return Array.isArray(definition)
            ? // if definition is ScreenName[]
                definition
            : // if definition is TStacksDataObj
                typeof definition === 'object'
                    ? definition.screens ?? []
                    : // if definition is StacksName -> look into stacks[...]
                        typeof definition === 'string'
                            ? // if stacks[name] is ScreenName[]
                                Array.isArray(stacks[definition])
                                    ? stacks[definition]
                                    : // if stacks[name] is TStacksDataObj
                                        typeof stacks[definition] === 'object'
                                            ? stacks[definition].screens ?? []
                                            : []
                            : [];
    };
    StackScreen = ({ StackNavigator, name }) => {
        const { screens, defaultOptions: globalDefaultOptions } = this.layout;
        const screen = screens[name];
        // component
        // -- handling when screen is a component or object{component,options}
        let sComponent;
        let sOptions;
        if (typeof screen === 'object') {
            if (screen.component) {
                // {component,options}
                sComponent = screen.component;
                sOptions = screen.options ?? {};
            }
            else {
                // component
                // this might happen if a screen is provided as wrapped component, for ex. const Main: React.FC = observer(() => {}); (observer from mobx)
                sComponent = screen;
                sOptions = {};
            }
        }
        else {
            // component
            sComponent = screen;
            sOptions = {};
        }
        const C = sComponent;
        // options
        const customDefaultOptions = this.getCustomDefaultOptions()?.stacks?.screen ?? {};
        const defaultOptions = globalDefaultOptions?.stacks?.screen ?? {};
        const Opts = props => ({
            ...safeOpts(customDefaultOptions)(props),
            ...safeOpts(defaultOptions)(props),
            ...safeOpts(sOptions)(props),
            ...safeOpts(C.options)(props), // component-based options
        }); // must be function. merge options from buildNavio and from component itself. also providing default options
        // screen
        return React.createElement(StackNavigator.Screen, { key: name, name: name, component: C, options: Opts });
    };
    Stack = ({ definition }) => {
        if (!definition)
            return null;
        const { screens, stacks, hooks } = this.layout;
        // -- running hooks
        if (hooks)
            for (const h of hooks)
                if (h)
                    h();
        if (!screens) {
            this.log('No screens registered');
            return React.createElement(React.Fragment, null);
        }
        if (!stacks) {
            this.log('No stacks registered');
            return React.createElement(React.Fragment, null);
        }
        // -- building navigator
        const Stack = createNativeStackNavigator();
        const StackScreensMemo = useMemo(() => {
            return this.__StackGetScreens(definition).map(sk => this.StackScreen({ StackNavigator: Stack, name: sk }));
        }, [definition, screens, stacks]);
        // -- getting navigator props
        const navigatorProps = this.__StackGetNavigatorProps(definition);
        return React.createElement(Stack.Navigator, { ...navigatorProps }, StackScreensMemo);
    };
    StackContainer = ({ Navigator, definition, name }) => {
        const { defaultOptions: globalDefaultOptions } = this.layout;
        // component
        const C = () => this.Stack({ definition });
        // options
        const customDefaultOptions = this.getCustomDefaultOptions()?.stacks?.container ?? {};
        const defaultOptions = globalDefaultOptions?.tabs?.container ?? {};
        const options = this.__StackGetContainerOpts(definition);
        const Opts = props => ({
            ...safeOpts(customDefaultOptions)(props),
            ...safeOpts(defaultOptions)(props),
            ...safeOpts(options)(props), // navio.stacks.[].options
        }); // must be function. merge options from buildNavio. also providing default options
        return (React.createElement(Navigator.Screen, { key: name, name: name, options: Opts }, (props) => React.createElement(C, { ...props })));
    };
    // | Tabs |
    __TabsGet = (definition) => {
        const { tabs } = this.layout;
        if (tabs === undefined)
            return undefined;
        const currentTabs = typeof definition === 'string' ? tabs[definition] : undefined;
        return currentTabs;
    };
    TabScreen = ({ TabNavigator, name, layout }) => {
        if (!layout.stack && !layout.drawer) {
            this.log(`Either 'stack' or 'drawer' must be provided for "${name}" tabs layout.`);
            return null;
        }
        // component
        const C = () => layout.stack
            ? this.Stack({ definition: layout.stack })
            : layout.drawer
                ? this.Drawer({ definition: layout.drawer })
                : null;
        return React.createElement(TabNavigator.Screen, { key: name, name: name, component: C });
    };
    Tabs = ({ definition }) => {
        const { tabs, hooks, defaultOptions: globalDefaultOptions } = this.layout;
        // -- pre-checks
        if (!tabs) {
            this.log('No tabs registered');
            return React.createElement(React.Fragment, null);
        }
        const currentTabs = this.__TabsGet(definition);
        if (!currentTabs) {
            this.log('No tabs defined found');
            return React.createElement(React.Fragment, null);
        }
        // -- internal state
        const [updatedOptions, setUpdatedOptions] = useState({});
        // -- internal effects
        useEffect(() => {
            this.tunnel.on('tabs.updateOptions', (params) => {
                const tcname = params.name;
                const tcopts = params.options;
                this.__tabsUpdatedOptions = {
                    ...this.__tabsUpdatedOptions,
                    [tcname]: { ...this.__tabsUpdatedOptions[tcname], ...tcopts },
                };
                setUpdatedOptions(this.__tabsUpdatedOptions);
            });
        }, [definition]);
        // -- internal memos
        const currentTabsLayout = useMemo(() => currentTabs.layout, [currentTabs]);
        const currentTabsLayoutKeys = useMemo(() => Object.keys(currentTabsLayout), [currentTabsLayout]);
        // -- running hooks
        if (hooks)
            for (const h of hooks)
                if (h)
                    h();
        // -- building navigator
        const Tabs = useMemo(() => createBottomTabNavigator(), [tabs]);
        const TabScreensMemo = useMemo(() => currentTabsLayoutKeys.map(key => this.TabScreen({
            name: key,
            TabNavigator: Tabs,
            layout: currentTabs.layout[key],
        })), [Tabs, currentTabsLayoutKeys]);
        // options
        const Opts = props => {
            const rName = props?.route?.name;
            if (!rName)
                return {};
            const customDefaultOptions = this.getCustomDefaultOptions()?.tabs?.screen ?? {};
            const defaultOpts = globalDefaultOptions?.tabs?.screen ?? {};
            const navigatorScreenOptions = currentTabs?.navigatorProps?.screenOptions ?? {};
            const options = currentTabs?.layout[rName]?.options ?? {};
            const _updatedOptions = updatedOptions[rName] ?? {};
            return {
                ...safeOpts(customDefaultOptions)(props),
                ...safeOpts(defaultOpts)(props),
                ...safeOpts(navigatorScreenOptions)(props),
                ...safeOpts(options)(props),
                ...safeOpts(_updatedOptions)(props), // upddated options (navio.tabs.updateOptions())
            };
        }; // must be function. merge options from buildNavio. also providing default options
        return (React.createElement(Tabs.Navigator, { ...currentTabs.navigatorProps, screenOptions: Opts }, TabScreensMemo));
    };
    TabsContainer = ({ Navigator, definition, name }) => {
        const { defaultOptions: globalDefaultOptions } = this.layout;
        // component
        const C = () => this.Tabs({ definition });
        // options
        const customDefaultOptions = this.getCustomDefaultOptions()?.tabs?.container ?? {};
        const defaultOptions = globalDefaultOptions?.tabs?.container ?? {};
        const options = this.__TabsGet(definition)?.options ?? {};
        const Opts = props => ({
            ...safeOpts(customDefaultOptions)(props),
            ...safeOpts(defaultOptions)(props),
            ...safeOpts(options)(props), // navio.tabs.[].options
        }); // must be function. merge options from buildNavio. also providing default options
        return React.createElement(Navigator.Screen, { key: name, name: name, component: C, options: Opts });
    };
    // | Drawers |
    __DrawerGet = (definition) => {
        const { drawers } = this.layout;
        if (drawers === undefined)
            return undefined;
        const current = typeof definition === 'string' ? drawers[definition] : undefined;
        return current;
    };
    DrawerScreen = ({ DrawerNavigator, name, layout }) => {
        if (!layout.stack && !layout.tabs) {
            this.log(`Either 'stack' or 'tabs' must be provided for "${name}" drawer layout.`);
            return null;
        }
        // component
        const C = () => layout.stack
            ? this.Stack({ definition: layout.stack })
            : layout.tabs
                ? this.Tabs({ definition: layout.tabs })
                : null;
        // screen
        return React.createElement(DrawerNavigator.Screen, { key: name, name: name, component: C });
    };
    Drawer = ({ definition }) => {
        const { drawers, defaultOptions: globalDefaultOptions, hooks } = this.layout;
        if (!drawers) {
            this.log('No drawers registered');
            return React.createElement(React.Fragment, null);
        }
        const currentDrawer = this.__DrawerGet(definition);
        if (!currentDrawer) {
            this.log('No drawer found');
            return React.createElement(React.Fragment, null);
        }
        // -- internal state
        const [updatedOptions, setUpdatedOptions] = useState({});
        // -- internal effects
        useEffect(() => {
            this.tunnel.on('drawer.updateOptions', (params) => {
                const name = params.name;
                const opts = params.options;
                this.__drawerUpdatedOptions = {
                    ...this.__drawerUpdatedOptions,
                    [name]: { ...this.__drawerUpdatedOptions[name], ...opts },
                };
                setUpdatedOptions(this.__drawerUpdatedOptions);
            });
        }, [definition]);
        // -- internal memos
        const currentDrawerLayout = useMemo(() => currentDrawer.layout, [currentDrawer]);
        const currentDrawerLayoutKeys = useMemo(() => Object.keys(currentDrawerLayout), [currentDrawerLayout]);
        // -- running hooks
        if (hooks)
            for (const h of hooks)
                if (h)
                    h();
        // -- building navigator
        const Drawer = useMemo(() => createDrawerNavigator(), [drawers]);
        const DrawerScreensMemo = useMemo(() => {
            return currentDrawerLayoutKeys.map(key => this.DrawerScreen({
                name: key,
                DrawerNavigator: Drawer,
                layout: currentDrawer.layout[key],
            }));
        }, [Drawer, currentDrawerLayoutKeys]);
        // options
        const Opts = props => {
            const rName = props?.route?.name;
            if (!rName)
                return {};
            const customDefaultOptions = this.getCustomDefaultOptions()?.drawers?.screen ?? {};
            const defaultOptions = globalDefaultOptions?.drawers?.screen ?? {};
            const navigatorScreenOptions = currentDrawer?.navigatorProps?.screenOptions ?? {};
            const options = currentDrawer?.layout[rName]?.options ?? {};
            const _updatedOptions = updatedOptions[rName] ?? {};
            return {
                ...safeOpts(customDefaultOptions)(props),
                ...safeOpts(defaultOptions)(props),
                ...safeOpts(navigatorScreenOptions)(props),
                ...safeOpts(options)(props),
                ...safeOpts(_updatedOptions)(props), // upddated options (navio.drawers.updateOptions())
            };
        }; // must be function. merge options from buildNavio. also providing default options
        return (React.createElement(Drawer.Navigator, { ...currentDrawer.navigatorProps, screenOptions: Opts }, DrawerScreensMemo));
    };
    DrawerContainer = ({ Navigator, definition, name }) => {
        const { defaultOptions: globalDefaultOptions } = this.layout;
        // component
        const C = () => this.Drawer({ definition });
        // options
        const customDefaultOptions = this.getCustomDefaultOptions()?.drawers?.container ?? {};
        const defaultOptions = globalDefaultOptions?.drawers?.container ?? {};
        const options = this.__DrawerGet(definition)?.options ?? {};
        const Opts = props => ({
            ...safeOpts(customDefaultOptions)(props),
            ...safeOpts(defaultOptions)(props),
            ...safeOpts(options)(props), // navio.stacks.[].options
        }); // must be function. merge options from buildNavio. also providing default options
        return React.createElement(Navigator.Screen, { key: name, name: name, component: C, options: Opts });
    };
    // | Modals |
    __ModalGet = (definition) => {
        const { modals } = this.layout;
        if (modals === undefined)
            return undefined;
        const currentModal = typeof definition === 'string' ? modals[definition] : undefined;
        return currentModal;
    };
    ModalContainer = ({ Navigator, definition, name }) => {
        const { defaultOptions: globalDefaultOptions } = this.layout;
        const currentModal = this.__ModalGet(definition);
        if (!currentModal) {
            this.log('No modal found');
            return React.createElement(React.Fragment, null);
        }
        // methods
        const clearParams = (name) => {
            this.__modalParams[name] = undefined;
        };
        // component
        const C = () => this.Stack({ definition: currentModal?.stack });
        // options
        const customDefaultOptions = this.getCustomDefaultOptions()?.modals?.container ?? {};
        const defaultOptions = globalDefaultOptions?.modals?.container ?? {};
        const options = currentModal?.options ?? {};
        const Opts = props => ({
            ...safeOpts(customDefaultOptions)(props),
            ...safeOpts(defaultOptions)(props),
            ...safeOpts(options)(props), // navio.modals.[].options
        }); // must be function. merge options from buildNavio. also providing default options
        return (React.createElement(Navigator.Screen, { key: name, name: name, component: C, options: Opts, 
            // we need to subscribe to Modals.Listeners.Blur to clear modals params
            listeners: ({ route }) => ({
                blur: e => clearParams(route?.name),
            }) }));
    };
    /**
     * Generates `<Root />` component for provided layout. Returns Stack Navigator.
     */
    Root = ({ root: parentRoot }) => {
        const { stacks, tabs, modals, drawers, root } = this.layout;
        const AppNavigator = createNativeStackNavigator();
        const appRoot = this.getSafeRoot(parentRoot ?? root);
        if (!appRoot) {
            this.log('No modal found');
            return React.createElement(React.Fragment, null);
        }
        // Effects
        useEffect(() => {
            // -- changing route if `root` was changed
            if (!!appRoot) {
                this.__setRoot(appRoot);
            }
            // listening to changes of parentRoot, but setting appRoot value
        }, [parentRoot]);
        // UI Methods
        // -- app stacks
        const AppStacks = useMemo(() => {
            if (!stacks)
                return null;
            const stacksKeys = Object.keys(stacks);
            return stacksKeys.map(key => this.StackContainer({ Navigator: AppNavigator, name: key, definition: stacks[key] }));
        }, [stacks]);
        // -- app tabs
        const AppTabs = useMemo(() => {
            if (!tabs)
                return null;
            const tabsKeys = Object.keys(tabs);
            return tabsKeys.map(key => this.TabsContainer({ Navigator: AppNavigator, name: key, definition: key }));
        }, [tabs]);
        // -- app drawers
        const AppDrawers = useMemo(() => {
            if (!drawers)
                return null;
            const drawersKeys = Object.keys(drawers);
            return drawersKeys.map(key => this.DrawerContainer({ Navigator: AppNavigator, name: key, definition: key }));
        }, [drawers]);
        // -- app modals
        const AppModals = useMemo(() => {
            if (!modals)
                return null;
            const modalsKeys = Object.keys(modals);
            return modalsKeys.map(key => this.ModalContainer({ Navigator: AppNavigator, name: key, definition: key }));
        }, [modals]);
        // -- app root
        const AppRoot = useMemo(() => {
            return (React.createElement(AppNavigator.Navigator, { initialRouteName: appRoot },
                React.createElement(AppNavigator.Group, null, AppStacks),
                React.createElement(AppNavigator.Group, null, AppTabs),
                React.createElement(AppNavigator.Group, null, AppDrawers),
                React.createElement(AppNavigator.Group, { screenOptions: { presentation: 'modal' } }, AppModals)));
        }, [appRoot]);
        return AppRoot;
    };
    /**
     * Generates your app's root component for provided layout.
     * Can be used as `<AppProviders><navio.App /></AppProviders>`
     */
    App = ({ navigationContainerProps, root: parentRoot }) => {
        // Navigation-related methods
        const _navContainerRef = (instance) => {
            this.navRef.current = instance;
        };
        const _navContainerOnReady = () => {
            this.navIsReadyRef.current = true;
            if (navigationContainerProps?.onReady) {
                navigationContainerProps?.onReady();
            }
        };
        return (React.createElement(NavigationContainer, { ...navigationContainerProps, ref: _navContainerRef, onReady: _navContainerOnReady },
            React.createElement(this.Root, { root: parentRoot })));
    };
}
